import type {
	AppComponentMetadata,
	AppComponentMetadataRemoteIDs,
	LocalAppOrigin,
	LocalAppOriginWithSecret,
} from './types/makecomapp.types';
import { ComponentIdMappingHelper } from './helpers/component-id-mapping-helper';
import { getAppComponentDetails } from '../services/get-app-components';
import { getModuleDefFromId } from '../services/module-types-naming';
import type { AppComponentType } from '../types/app-component-type.types';
import {
	ConnectionComponentDetailsApiResponseItem,
	ModuleComponentDetailsApiResponseItem,
	WebhookComponentDetailsApiResponseItem,
} from '../types/get-component-api-response.types';
import type { MakecomappJsonFile } from './helpers/makecomapp-json-file-class';

/**
 * Gets component in remote origin (in Make).
 */
export async function getRemoteComponent(
	origin: LocalAppOriginWithSecret,
	componentType: AppComponentType,
	componentName: string,
): Promise<AppComponentMetadataRemoteIDs> {
	// Process all app's compoments
	const componentDetail = await getAppComponentDetails(componentType, componentName, origin);

	// Create section in makecomapp.json
	const componentMetadata: AppComponentMetadataRemoteIDs = {
		label: componentDetail.label,
	};
	switch (componentType) {
		case 'connection':
			if (componentDetail.type === undefined) {
				// This should not occur on production. It is here for input validation only.
				throw new Error(`Missing expected property 'type' on remote ${componentType} ${componentDetail.name}.`);
			}
			componentMetadata.connectionType = (componentDetail as ConnectionComponentDetailsApiResponseItem).type;
			break;
		case 'webhook':
			if (componentDetail.type === undefined) {
				// This should not occur on production. It is here for input validation only.
				throw new Error(`Missing expected property 'type' on remote ${componentType} ${componentDetail.name}.`);
			}
			componentMetadata.webhookType = (componentDetail as WebhookComponentDetailsApiResponseItem).type;

			break;
		case 'module':
			componentMetadata.description = componentDetail.description;

			if (componentDetail.typeId === undefined) {
				// This should not occur on production. It is here for input validation only.
				throw new Error(
					`Missing expected property 'typeId' on remote ${componentType} ${componentDetail.name}.`,
				);
			}
			componentMetadata.moduleType = getModuleDefFromId(
				(componentDetail as ModuleComponentDetailsApiResponseItem).typeId,
			).type;

			if (componentMetadata.moduleType === 'action') {
				if (componentDetail.crud === undefined) {
					// This should not occur on production. It is here for input validation only.
					throw new Error(
						`Missing expected property 'crud' on remote ${componentType} ${componentDetail.name}.`,
					);
				}
				componentMetadata.actionCrud = (componentDetail as ModuleComponentDetailsApiResponseItem).crud;
			}
			break;
	}

	// Load additional/specific properties
	if (['module', 'webhook', 'rpc'].includes(componentType)) {
		// Add `connection` and `altConnection`
		if (componentDetail.connection === undefined) {
			// This should not occur on production. It is here for input validation only.
			throw new Error(
				`Missing expected property 'connection' on remote ${componentType} ${componentDetail.name}.`,
			);
		}
		if (componentDetail.altConnection === undefined) {
			// This should not occur on production. It is here for input validation only.
			throw new Error(
				`Missing expected property 'altConnection' on remote ${componentType} ${componentDetail.name}.`,
			);
		}
		componentMetadata.connection = componentDetail.connection;

		componentMetadata.altConnection = componentDetail.altConnection;

		// Add reference from Instant Trigger to Webhook
		if (componentType === 'module' && componentMetadata.moduleType === 'instant_trigger') {
			if (componentDetail.webhook === undefined) {
				// This should not occur on production. It is here for input validation only.
				throw new Error(
					`Missing expected property 'webhook' on remote ${componentMetadata.moduleType} ${componentType} ${componentDetail.name}.`,
				);
			}
			componentMetadata.webhook = (componentDetail as ModuleComponentDetailsApiResponseItem).webhook;
		}
	}

	return componentMetadata;
}

/**
 * Takes the structure, where component references are using remote component name and coverts it into local IDs.
 * Note: The purpose is to convert data generated by `getRemoteComponentsSummary()` function during pulling app.
 *
 * If local ID not found, it will create new one in idMapping.
 *
 * NOTE: Updates `makecomappJsonFile`. Changes must be saved after this function call.
 */
export async function convertComponentMetadataRemoteNamesToLocalIds(
	componentMetadata: AppComponentMetadataRemoteIDs, // from API
	componentIdMapping: ComponentIdMappingHelper,
	makecomappJsonFile: MakecomappJsonFile,
	origin: LocalAppOrigin,
): Promise<AppComponentMetadata> {
	const updatedComponentMedatada: AppComponentMetadata = {
		...(componentMetadata as unknown as AppComponentMetadata), // Conversion to Local IDs below
	};
	if (componentMetadata.connection) {
		// If remote connection name is defined
		updatedComponentMedatada.connection = await makecomappJsonFile.getLocalIdOrCreateNew(
			'connection',
			origin,
			componentMetadata.connection,
		);

		/*if (updatedComponentMedatada.connection === null) {
			delete updatedComponentMedatada.connection;
			// Explanation: Covers the special case, where `ignore this component` is defined in ID mapping.
			//   For this case, do not store (and manage) this reference.
		} else if (updatedComponentMedatada.connection === undefined) {
			// Missing the idMapping, so create new one.
			makecomappJsonFile.getComponentIdMappingHelper(origin).addComponentIdMapping(
				'connection',
				componentMetadata.connectionRemoteId, // TODO implement
				null, // null means 'ignore this component'
			);
		}*/
	}
	if (componentMetadata.altConnection) {
		updatedComponentMedatada.altConnection = await makecomappJsonFile.getLocalIdOrCreateNew(
			'connection',
			origin,
			componentMetadata.altConnection,
		);
		/*if (updatedComponentMedatada.altConnection === null) {
			delete updatedComponentMedatada.altConnection;
			// Explanation: Covers the special case, where `ignore this component` is defined in ID mapping.
			//   For this case, do not store (and manage) this reference.
		}*/
	}
	if (updatedComponentMedatada.webhook) {
		updatedComponentMedatada.webhook = componentIdMapping.getExistingLocalId(
			'webhook',
			updatedComponentMedatada.webhook,
		);
		if (updatedComponentMedatada.webhook === null) {
			delete updatedComponentMedatada.webhook;
			// Explanation: Covers the special case, where `ignore this component` is defined in ID mapping.
			//   For this case, do not store (and manage) this reference.
		}
	}
	return updatedComponentMedatada;
}
