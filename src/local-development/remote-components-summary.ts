import * as vscode from 'vscode';
import { AppComponentMetadata, LocalAppOriginWithSecret } from './types/makecomapp.types';
import { ComponentIdMappingHelper } from './helpers/component-id-mapping-helper';
import { RemoteComponentsSummary } from './types/remote-components-summary.types';
import { getAppComponentTypes } from '../services/component-code-def';
import { getAppComponentDetails, getAppComponents } from '../services/get-app-components';
import {
	ComponentsApiResponseConnectionItem,
	ComponentsApiResponseItem,
	ComponentsApiResponseModuleItem,
	ComponentsApiResponseWebhookItem,
} from '../types/get-component-api-response.types';
import { getModuleDefFromId } from '../services/module-types-naming';

/**
 * Gets list of all components in remote origin (in Make).
 * All component references are in their remote component names (not as Local IDs).
 */
export async function getRemoteComponentsSummary(
	anyProjectPath: vscode.Uri,
	origin: LocalAppOriginWithSecret,
): Promise<RemoteComponentsSummary> {
	const components: Awaited<ReturnType<typeof getRemoteComponentsSummary>> = {
		connection: {},
		webhook: {},
		module: {},
		rpc: {},
		function: {},
	};

	// Process all app's compoments
	for (const appComponentType of getAppComponentTypes()) {
		const appComponentSummaryList = await getAppComponents<ComponentsApiResponseItem>(appComponentType, origin);

		for (const appComponentSummary of appComponentSummaryList) {
			// Create section in makecomapp.json
			const componentMetadata: AppComponentMetadata = {
				label: appComponentSummary.label,
			};
			switch (appComponentType) {
				case 'connection':
					componentMetadata.connectionType = (
						appComponentSummary as ComponentsApiResponseConnectionItem
					).type;
					break;
				case 'webhook':
					componentMetadata.webhookType = (appComponentSummary as ComponentsApiResponseWebhookItem).type;

					break;
				case 'module':
					componentMetadata.description = appComponentSummary.description;
					componentMetadata.moduleType = getModuleDefFromId(
						(appComponentSummary as ComponentsApiResponseModuleItem).typeId,
					).type;
					if (componentMetadata.moduleType === 'action') {
						componentMetadata.actionCrud = (appComponentSummary as ComponentsApiResponseModuleItem).crud;
					}
					break;
			}

			// Load additional/specific properties
			if (['module', 'webhook', 'rpc'].includes(appComponentType)) {
				const componentDetails = await getAppComponentDetails(
					appComponentType,
					appComponentSummary.name,
					origin,
				);
				// Add `connection` and `altConnection`
				if (componentDetails.connection === undefined) {
					// This should not occure on production. It is here for input validation only.
					throw new Error(
						`Missing expected property 'connection' on remote ${appComponentType} ${appComponentSummary.name}.`,
					);
				}
				if (componentDetails.altConnection === undefined) {
					// This should not occure on production. It is here for input validation only.
					throw new Error(
						`Missing expected property 'altConnection' on remote ${appComponentType} ${appComponentSummary.name}.`,
					);
				}
				componentMetadata.connection = componentDetails.connection;

				componentMetadata.altConnection = componentDetails.altConnection;

				// Add reference from Instant Trigger to Webhook
				if (appComponentType === 'module' && componentMetadata.moduleType === 'instant_trigger') {
					if (componentDetails.webhook === undefined) {
						// This should not occure on production. It is here for input validation only.
						throw new Error(
							`Missing expected property 'webhook' on remote ${componentMetadata.moduleType} ${appComponentType} ${appComponentSummary.name}.`,
						);
					}
					componentMetadata.webhook = componentDetails.webhook;
				}
			}

			components[appComponentType][appComponentSummary.name] = componentMetadata;
		}
	}

	return components;
}

/**
 * Takes the structure, where component references are using remote component name and coverts it into local IDs.
 * Note: The purpose is to convert data generated by `getRemoteComponentsSummary()` function during pulling app.
 */
export function convertComponentMetadataRemoteNamesToLocalIds(
	componentMetadata: AppComponentMetadata,
	componentIdMapping: ComponentIdMappingHelper,
): AppComponentMetadata {
	const updatedComponentMedatada: AppComponentMetadata = {
		...componentMetadata,
	};
	if (updatedComponentMedatada.connection) {
		updatedComponentMedatada.connection = componentIdMapping.getExistingLocalId(
			'connection',
			updatedComponentMedatada.connection,
		);
		if (updatedComponentMedatada.connection === null) {
			delete updatedComponentMedatada.connection;
			// Explanation: Covers the special case, where `ignore this component` is defined in ID mapping.
			//   For this case, do not store (and manage) this reference.
		}
	}
	if (updatedComponentMedatada.altConnection) {
		updatedComponentMedatada.altConnection = componentIdMapping.getExistingLocalId(
			'connection',
			updatedComponentMedatada.altConnection,
		);
		if (updatedComponentMedatada.altConnection === null) {
			delete updatedComponentMedatada.altConnection;
			// Explanation: Covers the special case, where `ignore this component` is defined in ID mapping.
			//   For this case, do not store (and manage) this reference.
		}
	}
	if (updatedComponentMedatada.webhook) {
		updatedComponentMedatada.webhook = componentIdMapping.getExistingLocalId(
			'webhook',
			updatedComponentMedatada.webhook,
		);
		if (updatedComponentMedatada.webhook === null) {
			delete updatedComponentMedatada.webhook;
			// Explanation: Covers the special case, where `ignore this component` is defined in ID mapping.
			//   For this case, do not store (and manage) this reference.
		}
	}
	return updatedComponentMedatada;
}
