import { AppComponentMetadata, LocalAppOriginWithSecret } from './types/makecomapp.types';
import { ComponentIdMappingHelper } from './helpers/component-id-mapping-helper';
import { getAppComponentDetails } from '../services/get-app-components';
import { getModuleDefFromId } from '../services/module-types-naming';
import { AppComponentType } from '../types/app-component-type.types';
import {
	ConnectionComponentDetailsApiResponseItem,
	ModuleComponentDetailsApiResponseItem,
	WebhookComponentDetailsApiResponseItem,
} from '../types/get-component-api-response.types';

/**
 * Gets component in remote origin (in Make).
 */
export async function getRemoteComponent(
	origin: LocalAppOriginWithSecret,
	componentType: AppComponentType,
	componentName: string,
): Promise<AppComponentMetadata> {
	// Process all app's compoments
	const componentDetail = await getAppComponentDetails(componentType, componentName, origin);

	// Create section in makecomapp.json
	const componentMetadata: AppComponentMetadata = {
		label: componentDetail.label,
	};
	switch (componentType) {
		case 'connection':
			if (componentDetail.type === undefined) {
				// This should not occur on production. It is here for input validation only.
				throw new Error(`Missing expected property 'type' on remote ${componentType} ${componentDetail.name}.`);
			}
			componentMetadata.connectionType = (componentDetail as ConnectionComponentDetailsApiResponseItem).type;
			break;
		case 'webhook':
			if (componentDetail.type === undefined) {
				// This should not occur on production. It is here for input validation only.
				throw new Error(`Missing expected property 'type' on remote ${componentType} ${componentDetail.name}.`);
			}
			componentMetadata.webhookType = (componentDetail as WebhookComponentDetailsApiResponseItem).type;

			break;
		case 'module':
			componentMetadata.description = componentDetail.description;

			if (componentDetail.typeId === undefined) {
				// This should not occur on production. It is here for input validation only.
				throw new Error(`Missing expected property 'typeId' on remote ${componentType} ${componentDetail.name}.`);
			}
			componentMetadata.moduleType = getModuleDefFromId(
				(componentDetail as ModuleComponentDetailsApiResponseItem).typeId,
			).type;

			if (componentMetadata.moduleType === 'action') {
				if (componentDetail.crud === undefined) {
					// This should not occur on production. It is here for input validation only.
					throw new Error(`Missing expected property 'crud' on remote ${componentType} ${componentDetail.name}.`);
				}
				componentMetadata.actionCrud = (componentDetail as ModuleComponentDetailsApiResponseItem).crud;
			}
			break;
	}

	// Load additional/specific properties
	if (['module', 'webhook', 'rpc'].includes(componentType)) {
		// Add `connection` and `altConnection`
		if (componentDetail.connection === undefined) {
			// This should not occur on production. It is here for input validation only.
			throw new Error(
				`Missing expected property 'connection' on remote ${componentType} ${componentDetail.name}.`,
			);
		}
		if (componentDetail.altConnection === undefined) {
			// This should not occur on production. It is here for input validation only.
			throw new Error(
				`Missing expected property 'altConnection' on remote ${componentType} ${componentDetail.name}.`,
			);
		}
		componentMetadata.connection = componentDetail.connection;

		componentMetadata.altConnection = componentDetail.altConnection;

		// Add reference from Instant Trigger to Webhook
		if (componentType === 'module' && componentMetadata.moduleType === 'instant_trigger') {
			if (componentDetail.webhook === undefined) {
				// This should not occur on production. It is here for input validation only.
				throw new Error(
					`Missing expected property 'webhook' on remote ${componentMetadata.moduleType} ${componentType} ${componentDetail.name}.`,
				);
			}
			componentMetadata.webhook = (componentDetail as ModuleComponentDetailsApiResponseItem).webhook;
		}
	}

	return componentMetadata;
}

/**
 * Takes the structure, where component references are using remote component name and coverts it into local IDs.
 * Note: The purpose is to convert data generated by `getRemoteComponentsSummary()` function during pulling app.
 */
export function convertComponentMetadataRemoteNamesToLocalIds(
	componentMetadata: AppComponentMetadata,
	componentIdMapping: ComponentIdMappingHelper,
): AppComponentMetadata {
	const updatedComponentMedatada: AppComponentMetadata = {
		...componentMetadata,
	};
	if (updatedComponentMedatada.connection) {
		updatedComponentMedatada.connection = componentIdMapping.getExistingLocalId(
			'connection',
			updatedComponentMedatada.connection,
		);
		if (updatedComponentMedatada.connection === null) {
			delete updatedComponentMedatada.connection;
			// Explanation: Covers the special case, where `ignore this component` is defined in ID mapping.
			//   For this case, do not store (and manage) this reference.
		}
	}
	if (updatedComponentMedatada.altConnection) {
		updatedComponentMedatada.altConnection = componentIdMapping.getExistingLocalId(
			'connection',
			updatedComponentMedatada.altConnection,
		);
		if (updatedComponentMedatada.altConnection === null) {
			delete updatedComponentMedatada.altConnection;
			// Explanation: Covers the special case, where `ignore this component` is defined in ID mapping.
			//   For this case, do not store (and manage) this reference.
		}
	}
	if (updatedComponentMedatada.webhook) {
		updatedComponentMedatada.webhook = componentIdMapping.getExistingLocalId(
			'webhook',
			updatedComponentMedatada.webhook,
		);
		if (updatedComponentMedatada.webhook === null) {
			delete updatedComponentMedatada.webhook;
			// Explanation: Covers the special case, where `ignore this component` is defined in ID mapping.
			//   For this case, do not store (and manage) this reference.
		}
	}
	return updatedComponentMedatada;
}
